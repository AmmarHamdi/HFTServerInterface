# HFTServerInterface

![CI](https://github.com/AmmarHamdi/HFTServerInterface/actions/workflows/ci.yml/badge.svg?branch=main)

A **C++ Linux server interface** for a High-Frequency Trading (HFT) application
being migrated from a monolithic Windows MFC client to a **3-tier architecture**.
The server exposes all business logic services to a Windows GUI client while
remaining completely agnostic of the communication stack.

---

## Project Structure

```
HFTServerInterface/
├── include/               # Public interfaces & models (shared headers)
│   ├── models/            #   Request, Response, ReportRequest
│   ├── server/            #   IServerFacade, ICommand, CommandRegistry, RequestTypes
│   ├── services/          #   IMarketDataService, ICalculationService,
│   │                      #   IManipulationService, IReportService
│   │   └── reports/       #   BaseReport
│   └── transport/         #   ITransport
├── shared/                # Cross-platform POD structs (client + server)
│   ├── models/            #   MarketData
│   └── pod/               #   TradingPOD (pragma-packed binary structs)
├── src/
│   ├── main.cpp           # ★ Server entry point — wires all layers together
│   ├── server/
│   │   ├── TradingServerFacade.hpp/.cpp
│   │   ├── CommandRegistry.cpp
│   │   ├── StubServices.hpp   # Placeholder service implementations
│   │   └── commands/          # GetMarketDataCommand, CalculationCommand,
│   │                          # ManipulationCommand, ReportCommand
│   ├── services/
│   │   └── reports/           # BaseReport, EndOfDayReport
│   └── transport/
│       └── BoostAsioSslTransport.hpp/.cpp
├── tests/
│   ├── unit/              # GTest + GMock unit tests
│   └── bdd/               # Cucumber-cpp BDD feature files + step stubs
├── certs/                 # TLS certificates (git-ignored; generated by script)
│   └── README             # Instructions for regenerating certs
└── scripts/
    └── gen_certs.sh       # ★ Self-signed certificate generator
```

---

## Entry Point (`src/main.cpp`)

`main.cpp` is the application bootstrap. On startup it:

1. Parses optional command-line arguments (port, cert path, key path).
2. Instantiates the four **stub service** implementations from
   `src/server/StubServices.hpp` (replace each with a real implementation
   once the database layer is ready).
3. Populates a `CommandRegistry` with a factory lambda for every `RequestType`.
4. Constructs a `TradingServerFacade` with the registry and services injected.
5. Constructs a `BoostAsioSslTransport` and calls `start()`.
6. Installs `SIGINT` / `SIGTERM` handlers that call `transport.stop()` for a
   clean shutdown.

### Stub services (`src/server/StubServices.hpp`)

| Class | Interface | Current behaviour |
|---|---|---|
| `StubMarketDataService` | `IMarketDataService` | Returns `{false, "…not yet implemented", {}}` |
| `StubCalculationService` | `ICalculationService` | Returns `{false, "…not yet implemented", {}}` |
| `StubManipulationService` | `IManipulationService` | Returns `{false, "…not yet implemented", {}}` |
| `StubReportService` | `IReportService` | Returns `{false, "…not yet implemented for <type>", {}}` |

The stubs live in a separate header so the unit-test suite can instantiate and
exercise them directly (see `tests/unit/test_ServerBootstrap.cpp`).

---

```
┌─────────────────────────────────────────────────────────┐
│                    CLIENT (Windows MFC)                  │
│                      [OUT OF SCOPE]                     │
└──────────────────────────┬──────────────────────────────┘
                           │ Boost.Asio + SSL + POD
┌──────────────────────────▼──────────────────────────────┐
│                   TRANSPORT LAYER                        │
│              ITransport ◄── BoostAsioSslTransport        │
├─────────────────────────────────────────────────────────┤
│                SERVER INTERFACE LAYER                    │
│         IServerFacade ◄── TradingServerFacade           │
│              CommandRegistry / Dispatcher               │
├─────────────────────────────────────────────────────────┤
│                   SERVICE LAYER                          │
│   IMarketDataService  │  ICalculationService            │
│   IManipulationService│  IReportService                 │
├─────────────────────────────────────────────────────────┤
│                  DATABASE LAYER                          │
│                PostgreSQL [OUT OF SCOPE]                 │
└─────────────────────────────────────────────────────────┘
```

---

## Communication Stack

**Iteration 1:** Boost.Asio + SSL/TLS + binary POD structs
(`shared/pod/TradingPOD.hpp`).

The transport is fully abstracted behind `ITransport`. To swap the
communication stack (e.g., replace Boost.Asio with gRPC):

1. Create a new class that inherits `ITransport`.
2. Implement `send()`, `receive()`, `start()`, `stop()`.
3. Inject the new implementation at startup — no changes to the server
   or service layers are required.

---

## Design Patterns

| Pattern | Layer | Purpose |
|---|---|---|
| **Facade** | Server Interface | Single entry point via `TradingServerFacade` |
| **Command** | Server Interface | Encapsulate each operation as an `ICommand` |
| **Registry / Factory** | Server Interface | `CommandRegistry` maps `RequestType` → factory |
| **Template Method** | Services / Reports | `BaseReport` defines a fixed pipeline; subclasses fill in steps |
| **Dependency Injection** | All | Services injected as `std::shared_ptr` via constructors |
| **Interface Segregation** | All | Each service has its own focused interface |

---

## Services

| Interface | Responsibility |
|---|---|
| `IMarketDataService` | Retrieve real-time / historical prices; subscribe/unsubscribe to symbols |
| `ICalculationService` | Execute financial calculations (P&L, VaR, Greeks) |
| `IManipulationService` | Filter, transform, and aggregate trading data |
| `IReportService` | Generate structured reports (e.g., end-of-day summary) |

---

## Extensibility Guide

### Adding a new service

1. Create `include/services/IMyNewService.hpp` — pure virtual interface.
2. Create `src/services/MyNewService.hpp/.cpp` — concrete implementation.
3. Add `std::shared_ptr<IMyNewService>` parameter to `TradingServerFacade`.
4. Add a new `RequestType` value in `include/server/RequestTypes.hpp`.
5. Create a command in `src/server/commands/MyNewCommand.hpp`.
6. Register the factory in `CommandRegistry` bootstrap code.

### Modifying an existing service

1. Add the new method signature to the relevant `IXxxService.hpp` interface.
2. Implement the method in the concrete service class.
3. Update GMock mock classes in the unit test files.

### Adding a new report type

1. Create `src/services/reports/MyNewReport.hpp/.cpp`.
2. Inherit `BaseReport`; override `fetchData()`, `computeReport()`, `format()`.
3. In the concrete `IReportService` implementation, dispatch on
   `ReportRequest::reportType` to instantiate the new report class.

### Adding a new transport (e.g., gRPC)

1. Create `src/transport/GrpcTransport.hpp/.cpp`.
2. Inherit `ITransport`; implement all four methods.
3. Replace `BoostAsioSslTransport` at the application entry point.

### Adding a new request type

1. Add a new enumerator to `RequestType` in `include/server/RequestTypes.hpp`.
2. Create the corresponding command in `src/server/commands/`.
3. Register the factory in the application bootstrap code using
   `CommandRegistry::registerCommand()`.

---

## Shared Cross-Platform Code (`shared/`)

The `shared/` directory contains headers that are compiled on **both** the
Windows MFC client and the Linux server:

- **`shared/pod/TradingPOD.hpp`** — `#pragma pack(1)` POD structs
  (`MarketDataPOD`, `OrderPOD`, `PositionPOD`, `TradePOD`) transmitted as
  raw binary over the transport layer.
- **`shared/models/MarketData.hpp`** — compact `MarketData` struct for
  real-time price snapshots.

**Rules for shared code:**
- Only plain-old-data (no `std::string`, no virtual methods, no pointers).
- Fixed-size primitive members only.
- Always use `#pragma pack(push, 1)` / `#pragma pack(pop)`.

---

## Testing Strategy

| Level | Framework | Scope | Test files |
|---|---|---|---|
| **Unit** | GTest + GMock | Single class / method | `test_CommandRegistry`, `test_TradingServerFacade`, `test_MarketDataService`, `test_CalculationService`, `test_ManipulationService`, `test_EndOfDayReport`, **`test_ServerBootstrap`** |
| **BDD** | Cucumber-cpp | End-to-end feature scenarios | `tests/bdd/features/*.feature` + step definitions |

`test_ServerBootstrap` specifically covers:
- Each `StubXxxService` returns a well-formed `{false, "…", {}}` response.
- The full registry + facade wiring (as done in `main()`) dispatches all four
  `RequestType` values end-to-end without throwing.

---

## Certificate Management

The server requires a PEM-encoded certificate and private key for TLS.
Both files are stored in `certs/` and are **excluded from version control**
(see `.gitignore`).

### Generate certificates

```bash
# Defaults: RSA-2048, 365-day validity, CN=localhost, output → certs/
./scripts/gen_certs.sh

# Custom options
./scripts/gen_certs.sh --cn myserver.example.com --days 730 --bits 4096

# Full usage
./scripts/gen_certs.sh --help
```

The script automatically uses the OpenSSL CLI if it is on `$PATH`, or falls
back to compiling a small C helper against the OpenSSL shared libraries.

| Output file | Purpose | Permissions |
|---|---|---|
| `certs/server.crt` | Self-signed X.509 certificate | `644` |
| `certs/server.key` | RSA private key | `600` |

> **Production note:** Replace the self-signed certificate with one issued by
> a trusted CA (e.g., Let's Encrypt) before deploying to a live environment.

---

## How to Build

```bash
# From the repository root
cmake -B build -S . -DCMAKE_BUILD_TYPE=Release
cmake --build build --parallel
```

This produces:
- `build/hft_server_exe` — the runnable server binary
- `build/tests/unit/hft_unit_tests` — the GTest unit test suite

**Requirements:** CMake ≥ 3.16, C++17 compiler, Boost (system), OpenSSL, GTest/GMock.

---

## How to Run the Server

```bash
# Generate TLS certificates first (only needed once)
./scripts/gen_certs.sh

# Run with defaults (port 8443, certs/server.crt, certs/server.key)
./build/hft_server_exe

# Run with custom port and certificate paths
./build/hft_server_exe <port> <cert.pem> <key.pem>

# Example
./build/hft_server_exe 9443 certs/server.crt certs/server.key
```

Stop the server cleanly with `Ctrl+C` (SIGINT) or `kill <pid>` (SIGTERM).

---

## How to Run Tests

Build first with `cmake -B build -S . -DCMAKE_BUILD_TYPE=Debug && cmake --build build --parallel` (see [How to Build](#how-to-build)).

### Unit tests (GTest)

```bash
cd build
ctest --output-on-failure
# or run the binary directly:
./tests/unit/hft_unit_tests
# run a single test suite:
./tests/unit/hft_unit_tests --gtest_filter='ServerBootstrapTest.*'
```

### BDD tests (Cucumber-cpp)

> **Note:** BDD step definitions contain `// TODO: IMPLEMENT` markers.
> Full BDD execution requires cucumber-cpp to be integrated and steps
> to be implemented.

```bash
# After implementing the steps:
cd build/tests/bdd
./hft_bdd_tests --format progress
```

---

## Out of Scope

- **Windows MFC GUI client** — The client application consumes the server
  interface but is not part of this repository.
- **PostgreSQL database layer** — Database access is handled by the concrete
  service implementations (stub/TODO stubs provided).

---

## TODO Markers Guide

| Marker | Meaning |
|---|---|
| `// TODO: EXTEND` | Extension point — add new services, commands, methods, or pipeline steps here |
| `// TODO: REGISTER` | Registration point — call `CommandRegistry::registerCommand()` for every new command here |
| `// TODO: IMPLEMENT` | Concrete logic is missing — fill in the actual business / I/O logic here |
